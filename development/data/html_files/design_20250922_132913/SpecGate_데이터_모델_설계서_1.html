<h2>1. 개요</h2><ul><li><p><strong>목적</strong>: SpecGate 시스템의 표준화된 데이터 구조 및 스키마 정의</p></li><li><p><strong>배경</strong>: Phase 간 데이터 전달 및 DesignRuleSpec 생성을 위한 일관된 데이터 모델 필요</p></li><li><p><strong>참고사항</strong>: JSON Schema 기반, Pydantic 모델 활용, MCP 표준 준수</p></li></ul><h2>2. 설계 규칙 (Design Rules)</h2><h3>2.1 MUST 규칙 (필수)</h3><ul><li><p><strong>RULE-DATA-001</strong> (MUST): 모든 데이터 모델은 JSON Schema로 정의해야 한다</p><ul><li><p>적용 범위: 모든 데이터 구조 (DocumentData, RuleData, DesignRuleSpec 등)</p></li><li><p>근거: 데이터 검증 및 직렬화/역직렬화 표준화</p></li><li><p>참조: JSON Schema 표준 (Draft 7)</p></li></ul></li><li><p><strong>RULE-DATA-002</strong> (MUST): 모든 데이터 모델은 Pydantic BaseModel을 상속해야 한다</p><ul><li><p>적용 범위: 모든 Python 데이터 클래스</p></li><li><p>근거: 타입 안전성 보장 및 자동 검증</p></li><li><p>참조: Pydantic v2 공식 문서</p></li></ul></li><li><p><strong>RULE-DATA-003</strong> (MUST): 모든 데이터 모델은 버전 관리가 가능해야 한다</p><ul><li><p>적용 범위: 모든 데이터 구조</p></li><li><p>근거: 하위 호환성 보장 및 스키마 진화 지원</p></li><li><p>참조: API 버전 관리 모범 사례</p></li></ul></li></ul><h3>2.2 SHOULD 규칙 (권장)</h3><ul><li><p><strong>RULE-DATA-004</strong> (SHOULD): 모든 데이터 모델은 메타데이터를 포함해야 한다</p><ul><li><p>적용 범위: 모든 데이터 구조</p></li><li><p>근거: 추적성 및 디버깅 효율성 향상</p></li><li><p>참조: 데이터 거버넌스 모범 사례</p></li></ul></li><li><p><strong>RULE-DATA-005</strong> (SHOULD): 모든 데이터 모델은 검증 규칙을 포함해야 한다</p><ul><li><p>적용 범위: 모든 데이터 구조</p></li><li><p>근거: 데이터 품질 보장 및 오류 방지</p></li><li><p>참조: 데이터 검증 모범 사례</p></li></ul></li></ul><h3>2.3 금지 규칙 (Prohibited)</h3><ul><li><p><strong>RULE-DATA-006</strong> (MUST NOT): 순환 참조를 가진 데이터 모델을 사용해서는 안 된다</p><ul><li><p>적용 범위: 모든 데이터 구조</p></li><li><p>근거: 직렬화 오류 및 성능 문제 방지</p></li><li><p>참조: 객체 지향 설계 원칙</p></li></ul></li><li><p><strong>RULE-DATA-007</strong> (MUST NOT): 하드코딩된 비즈니스 로직을 데이터 모델에 포함해서는 안 된다</p><ul><li><p>적용 범위: 모든 데이터 클래스</p></li><li><p>근거: 관심사 분리 및 유지보수성 향상</p></li><li><p>참조: Clean Architecture 설계 원칙</p></li></ul></li></ul><h2>3. 기술 스펙</h2><h3>3.1 데이터 모델 (ERD)</h3><ac:structured-macro ac:name="confluence-mermaid-macro" ac:schema-version="1" data-layout="default" ac:local-id="3d40be14-8ccb-4013-9f22-cc105e7fad91" ac:macro-id="436a96f1-4a57-46f2-bd77-aa303e217066"><ac:parameter ac:name="panZoom" /><ac:parameter ac:name="zoom" /><ac:parameter ac:name="look">classic</ac:parameter><ac:parameter ac:name="download" /><ac:parameter ac:name="searchText">erDiagram DocumentData string id PK string title string content string html_content string markdown_content string space_key string space_name string url array labels string created_at string updated_at object metadata QualityScore integer score array violations array suggestions string check_type object metadata string timestamp DesignRule string rule_id PK string area integer number string rule_type string description string scope string reason string reference object metadata DesignRuleSpec string spec_id PK string project_name string document_type array must_rules array should_rules array must_not_rules object technical_specs object rule_spec_relations object metadata ConversionResult string markdown object metadata object conversion_info string timestamp DocumentData QualityScore has DocumentData ConversionResult converts_to DocumentData DesignRule contains DesignRule DesignRuleSpec belongs_to QualityScore DesignRuleSpec validates</ac:parameter><ac:parameter ac:name="fullscreen" /><ac:parameter ac:name="theme">default</ac:parameter><ac:parameter ac:name="disableUseMaxWidth" /><ac:parameter ac:name="copy" /><ac:parameter ac:name="alignment">left</ac:parameter><ac:parameter ac:name="exportWidth" /><ac:parameter ac:name="height" /><ac:plain-text-body><![CDATA[[{"body":"erDiagram\n    DocumentData {\n        string id PK\n        string title\n        string content\n        string html_content\n        string markdown_content\n        string space_key\n        string space_name\n        string url\n        array labels\n        string created_at\n        string updated_at\n        object metadata\n    }\n    \n    QualityScore {\n        integer score\n        array violations\n        array suggestions\n        string check_type\n        object metadata\n        string timestamp\n    }\n    \n    DesignRule {\n        string rule_id PK\n        string area\n        integer number\n        string rule_type\n        string description\n        string scope\n        string reason\n        string reference\n        object metadata\n    }\n    \n    DesignRuleSpec {\n        string spec_id PK\n        string project_name\n        string document_type\n        array must_rules\n        array should_rules\n        array must_not_rules\n        object technical_specs\n        object rule_spec_relations\n        object metadata\n    }\n    \n    ConversionResult {\n        string markdown\n        object metadata\n        object conversion_info\n        string timestamp\n    }\n    \n    DocumentData ||--o{ QualityScore : \"has\"\n    DocumentData ||--o{ ConversionResult : \"converts_to\"\n    DocumentData ||--o{ DesignRule : \"contains\"\n    DesignRule ||--o{ DesignRuleSpec : \"belongs_to\"\n    QualityScore ||--o{ DesignRuleSpec : \"validates\"","date":1758265389889}]]]></ac:plain-text-body></ac:structured-macro><h3>3.2 JSON Schema 정의</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="2de59b2b-78c3-4fb8-84db-c8c6a5a9e463"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "DocumentData": {
      "type": "object",
      "properties": {
        "id": {"type": "string"},
        "title": {"type": "string"},
        "content": {"type": "string"},
        "html_content": {"type": "string"},
        "markdown_content": {"type": "string"},
        "space_key": {"type": "string"},
        "space_name": {"type": "string"},
        "url": {"type": "string", "format": "uri"},
        "labels": {
          "type": "array",
          "items": {"type": "string"}
        },
        "created_at": {"type": "string", "format": "date-time"},
        "updated_at": {"type": "string", "format": "date-time"},
        "metadata": {"type": "object"}
      },
      "required": ["id", "title", "content", "space_key", "labels"]
    },
    
    "QualityScore": {
      "type": "object",
      "properties": {
        "score": {"type": "integer", "minimum": 0, "maximum": 100},
        "violations": {
          "type": "array",
          "items": {"$ref": "#/definitions/Violation"}
        },
        "suggestions": {
          "type": "array",
          "items": {"type": "string"}
        },
        "check_type": {"type": "string", "enum": ["full", "basic", "structure"]},
        "metadata": {"type": "object"},
        "timestamp": {"type": "string", "format": "date-time"}
      },
      "required": ["score", "violations", "suggestions", "check_type"]
    },
    
    "DesignRule": {
      "type": "object",
      "properties": {
        "rule_id": {"type": "string", "pattern": "^RULE-[A-Z]+-[0-9]+$"},
        "area": {"type": "string", "enum": ["API", "DATA", "ARCH", "SEC", "PERF"]},
        "number": {"type": "integer", "minimum": 1},
        "rule_type": {"type": "string", "enum": ["MUST", "SHOULD", "MUST NOT"]},
        "description": {"type": "string"},
        "scope": {"type": "string"},
        "reason": {"type": "string"},
        "reference": {"type": "string"},
        "metadata": {"type": "object"}
      },
      "required": ["rule_id", "area", "number", "rule_type", "description"]
    },
    
    "DesignRuleSpec": {
      "type": "object",
      "properties": {
        "spec_id": {"type": "string"},
        "project_name": {"type": "string"},
        "document_type": {"type": "string"},
        "must_rules": {
          "type": "array",
          "items": {"$ref": "#/definitions/DesignRule"}
        },
        "should_rules": {
          "type": "array",
          "items": {"$ref": "#/definitions/DesignRule"}
        },
        "must_not_rules": {
          "type": "array",
          "items": {"$ref": "#/definitions/DesignRule"}
        },
        "technical_specs": {"type": "object"},
        "rule_spec_relations": {"type": "object"},
        "metadata": {"type": "object"}
      },
      "required": ["spec_id", "project_name", "document_type", "must_rules", "should_rules", "must_not_rules"]
    },
    
    "Violation": {
      "type": "object",
      "properties": {
        "rule_id": {"type": "string"},
        "severity": {"type": "string", "enum": ["error", "warning", "info"]},
        "message": {"type": "string"},
        "line_number": {"type": "integer"},
        "suggestion": {"type": "string"}
      },
      "required": ["rule_id", "severity", "message"]
    }
  }
}
]]></ac:plain-text-body></ac:structured-macro><h3>3.3 Pydantic 모델 정의</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="152ff04b-abc4-47bc-ac2d-d7dba29be61a"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class RuleArea(str, Enum):
    API = "API"
    DATA = "DATA"
    ARCH = "ARCH"
    SEC = "SEC"
    PERF = "PERF"

class RuleType(str, Enum):
    MUST = "MUST"
    SHOULD = "SHOULD"
    MUST_NOT = "MUST NOT"

class Severity(str, Enum):
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"

class CheckType(str, Enum):
    FULL = "full"
    BASIC = "basic"
    STRUCTURE = "structure"

class DocumentData(BaseModel):
    id: str
    title: str
    content: str
    html_content: Optional[str] = None
    markdown_content: Optional[str] = None
    space_key: str
    space_name: str
    url: str
    labels: List[str] = []
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    @validator('labels')
    def validate_labels(cls, v):
        if not isinstance(v, list):
            raise ValueError('labels must be a list')
        return v

class Violation(BaseModel):
    rule_id: str
    severity: Severity
    message: str
    line_number: Optional[int] = None
    suggestion: Optional[str] = None

class QualityScore(BaseModel):
    score: int = Field(ge=0, le=100)
    violations: List[Violation] = []
    suggestions: List[str] = []
    check_type: CheckType = CheckType.FULL
    metadata: Dict[str, Any] = Field(default_factory=dict)
    timestamp: datetime = Field(default_factory=datetime.now)

class DesignRule(BaseModel):
    rule_id: str = Field(pattern=r'^RULE-[A-Z]+-[0-9]+$')
    area: RuleArea
    number: int = Field(ge=1)
    rule_type: RuleType
    description: str
    scope: Optional[str] = None
    reason: Optional[str] = None
    reference: Optional[str] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    @validator('rule_id')
    def validate_rule_id(cls, v, values):
        if 'area' in values and 'number' in values:
            expected_id = f"RULE-{values['area']}-{values['number']:03d}"
            if v != expected_id:
                raise ValueError(f'rule_id must match pattern: {expected_id}')
        return v

class DesignRuleSpec(BaseModel):
    spec_id: str
    project_name: str
    document_type: str
    must_rules: List[DesignRule] = []
    should_rules: List[DesignRule] = []
    must_not_rules: List[DesignRule] = []
    technical_specs: Dict[str, Any] = Field(default_factory=dict)
    rule_spec_relations: Dict[str, Any] = Field(default_factory=dict)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    @validator('must_rules', 'should_rules', 'must_not_rules')
    def validate_rules(cls, v):
        for rule in v:
            if not isinstance(rule, DesignRule):
                raise ValueError('All rules must be DesignRule instances')
        return v

class ConversionResult(BaseModel):
    markdown: str
    metadata: Dict[str, Any] = Field(default_factory=dict)
    conversion_info: Dict[str, Any] = Field(default_factory=dict)
    timestamp: datetime = Field(default_factory=datetime.now)
]]></ac:plain-text-body></ac:structured-macro><h2>4. 구현 가이드</h2><h3>4.1 데이터 변환 유틸리티</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="06c37c76-0831-4441-9fde-f96d61efbc37"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[from typing import Type, TypeVar
import json

T = TypeVar('T', bound=BaseModel)

class DataConverter:
    @staticmethod
    def to_dict(model: BaseModel) -> Dict[str, Any]:
        """Pydantic 모델을 딕셔너리로 변환"""
        return model.dict()
    
    @staticmethod
    def to_json(model: BaseModel) -> str:
        """Pydantic 모델을 JSON 문자열로 변환"""
        return model.json()
    
    @staticmethod
    def from_dict(data: Dict[str, Any], model_class: Type[T]) -> T:
        """딕셔너리를 Pydantic 모델로 변환"""
        return model_class(**data)
    
    @staticmethod
    def from_json(json_str: str, model_class: Type[T]) -> T:
        """JSON 문자열을 Pydantic 모델로 변환"""
        data = json.loads(json_str)
        return model_class(**data)
    
    @staticmethod
    def validate_data(data: Dict[str, Any], model_class: Type[T]) -> bool:
        """데이터가 모델 스키마에 맞는지 검증"""
        try:
            model_class(**data)
            return True
        except Exception:
            return False
]]></ac:plain-text-body></ac:structured-macro><h3>4.2 데이터 직렬화/역직렬화</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="ec224c0d-8068-41d3-9114-97dbeeb80813"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import json
from datetime import datetime
from typing import Any

class DataSerializer:
    @staticmethod
    def serialize_datetime(obj: Any) -> str:
        """datetime 객체를 ISO 형식 문자열로 직렬화"""
        if isinstance(obj, datetime):
            return obj.isoformat()
        raise TypeError(f"Object of type {type(obj)} is not JSON serializable")
    
    @staticmethod
    def serialize_model(model: BaseModel) -> str:
        """Pydantic 모델을 JSON으로 직렬화"""
        return json.dumps(
            model.dict(),
            default=DataSerializer.serialize_datetime,
            ensure_ascii=False,
            indent=2
        )
    
    @staticmethod
    def deserialize_model(json_str: str, model_class: Type[T]) -> T:
        """JSON을 Pydantic 모델로 역직렬화"""
        data = json.loads(json_str)
        return model_class(**data)
]]></ac:plain-text-body></ac:structured-macro><h3>4.3 데이터 검증 규칙</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="bbe89b4c-3476-4d43-ad67-d1f47add2561"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[from pydantic import ValidationError

class DataValidator:
    @staticmethod
    def validate_document_data(data: Dict[str, Any]) -> List[str]:
        """DocumentData 검증 및 오류 메시지 반환"""
        errors = []
        try:
            DocumentData(**data)
        except ValidationError as e:
            for error in e.errors():
                field = error['loc'][0] if error['loc'] else 'unknown'
                message = error['msg']
                errors.append(f"{field}: {message}")
        return errors
    
    @staticmethod
    def validate_design_rule(rule: Dict[str, Any]) -> List[str]:
        """DesignRule 검증 및 오류 메시지 반환"""
        errors = []
        try:
            DesignRule(**rule)
        except ValidationError as e:
            for error in e.errors():
                field = error['loc'][0] if error['loc'] else 'unknown'
                message = error['msg']
                errors.append(f"{field}: {message}")
        return errors
    
    @staticmethod
    def validate_rule_id(rule_id: str) -> bool:
        """규칙 ID 형식 검증"""
        import re
        pattern = r'^RULE-[A-Z]+-[0-9]+$'
        return bool(re.match(pattern, rule_id))
]]></ac:plain-text-body></ac:structured-macro><h3>4.4 테스트 케이스</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="ecf3e372-2936-47ae-a3f1-8a9f9449ff42"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import pytest
from datetime import datetime

class TestDataModels:
    def test_document_data_creation(self):
        """DocumentData 생성 테스트"""
        doc = DocumentData(
            id="123",
            title="Test Document",
            content="Test content",
            space_key="TEST",
            space_name="Test Space",
            url="https://test.com",
            labels=["test", "example"]
        )
        assert doc.id == "123"
        assert doc.title == "Test Document"
        assert len(doc.labels) == 2
    
    def test_design_rule_validation(self):
        """DesignRule 검증 테스트"""
        rule = DesignRule(
            rule_id="RULE-API-001",
            area=RuleArea.API,
            number=1,
            rule_type=RuleType.MUST,
            description="Test rule"
        )
        assert rule.rule_id == "RULE-API-001"
        assert rule.area == RuleArea.API
    
    def test_quality_score_validation(self):
        """QualityScore 검증 테스트"""
        score = QualityScore(
            score=85,
            violations=[],
            suggestions=["Test suggestion"],
            check_type=CheckType.FULL
        )
        assert score.score == 85
        assert score.check_type == CheckType.FULL
]]></ac:plain-text-body></ac:structured-macro><h2>5. 변경 이력</h2><table data-table-width="760" data-layout="default" ac:local-id="528c8a63-863d-4b5d-ac8b-2d38c3e737b1"><tbody><tr><th><p>버전</p></th><th><p>날짜</p></th><th><p>변경내용</p></th><th><p>작성자</p></th></tr><tr><td><p>1.0</p></td><td><p>2024-01-15</p></td><td><p>초기 데이터 모델 설계서 작성</p></td><td><p>SpecGate Team</p></td></tr></tbody></table>