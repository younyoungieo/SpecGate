<h2>1. 개요</h2><ul><li><p><strong>목적</strong>: SpecGate 시스템의 성능 최적화 및 확장성 설계</p></li><li><p><strong>배경</strong>: 대용량 설계 문서 처리 및 실시간 CI 게이트 처리를 위한 성능 최적화 필요</p></li><li><p><strong>참고사항</strong>: 비동기 처리, 캐싱 전략, 메모리 최적화 적용</p></li></ul><h2>2. 설계 규칙 (Design Rules)</h2><h3>2.1 MUST 규칙 (필수)</h3><ul><li><p><strong>RULE-PERF-001</strong> (MUST): 모든 I/O 작업은 비동기로 처리해야 한다</p><ul><li><p>적용 범위: Confluence API 호출, 파일 읽기/쓰기, 네트워크 통신</p></li><li><p>근거: 동시 처리 성능 향상 및 리소스 효율성 극대화</p></li><li><p>참조: Python asyncio 모범 사례</p></li></ul></li><li><p><strong>RULE-PERF-002</strong> (MUST): 모든 외부 API 호출은 적절한 타임아웃을 설정해야 한다</p><ul><li><p>적용 범위: Confluence API, GitHub API 등 모든 외부 서비스 호출</p></li><li><p>근거: 무한 대기 방지 및 시스템 안정성 보장</p></li><li><p>참조: API 설계 모범 사례</p></li></ul></li><li><p><strong>RULE-PERF-003</strong> (MUST): 메모리 사용량은 1GB를 초과해서는 안 된다</p><ul><li><p>적용 범위: 모든 Phase의 메모리 사용</p></li><li><p>근거: 시스템 안정성 및 확장성 보장</p></li><li><p>참조: Python 메모리 관리 가이드</p></li></ul></li></ul><h3>2.2 SHOULD 규칙 (권장)</h3><ul><li><p><strong>RULE-PERF-004</strong> (SHOULD): 반복적인 작업은 캐싱을 활용해야 한다</p><ul><li><p>적용 범위: Confluence 문서 조회, 품질 검사 결과, 변환 결과</p></li><li><p>근거: 응답 시간 단축 및 외부 API 호출 최소화</p></li><li><p>참조: 캐싱 전략 모범 사례</p></li></ul></li><li><p><strong>RULE-PERF-005</strong> (SHOULD): 대용량 문서는 스트리밍으로 처리해야 한다</p><ul><li><p>적용 범위: HTML&rarr;MD 변환, 규칙 추출, 품질 검사</p></li><li><p>근거: 메모리 사용량 최적화 및 처리 성능 향상</p></li><li><p>참조: 스트리밍 처리 패턴</p></li></ul></li></ul><h3>2.3 금지 규칙 (Prohibited)</h3><ul><li><p><strong>RULE-PERF-006</strong> (MUST NOT): 동기 I/O 작업을 사용해서는 안 된다</p><ul><li><p>적용 범위: 모든 I/O 작업</p></li><li><p>근거: 성능 저하 및 블로킹 문제 발생</p></li><li><p>참조: 비동기 프로그래밍 원칙</p></li></ul></li><li><p><strong>RULE-PERF-007</strong> (MUST NOT): 무제한 메모리 할당을 사용해서는 안 된다</p><ul><li><p>적용 범위: 모든 데이터 처리</p></li><li><p>근거: 메모리 부족 및 시스템 불안정성 방지</p></li><li><p>참조: 메모리 관리 모범 사례</p></li></ul></li></ul><h2>3. 기술 스펙</h2><h3>3.1 성능 아키텍처 (Mermaid)</h3><ac:structured-macro ac:name="confluence-mermaid-macro" ac:schema-version="1" data-layout="default" ac:local-id="79d4c732-a29b-4749-bf1c-878633f6cb6a" ac:macro-id="1ee3b771-3395-45cc-9ab1-a1d3c0804fc6"><ac:parameter ac:name="panZoom" /><ac:parameter ac:name="zoom" /><ac:parameter ac:name="look">classic</ac:parameter><ac:parameter ac:name="download" /><ac:parameter ac:name="searchText">graph TB subgraph Client Layer MCP Client Request Queue Load Balancer end subgraph API Gateway Layer Rate Limiter Request Throttler Connection Pool end subgraph SpecGate Server Layer Async Task Queue Worker Pool Memory Manager Cache Layer end subgraph Processing Layer Document Parser Stream Processor Batch Processor Result Aggregator end subgraph Storage Layer Redis Cache Memory Cache Disk Cache end subgraph External Services Confluence API Connection Pool GitHub API Connection Pool end</ac:parameter><ac:parameter ac:name="fullscreen" /><ac:parameter ac:name="theme">default</ac:parameter><ac:parameter ac:name="disableUseMaxWidth" /><ac:parameter ac:name="copy" /><ac:parameter ac:name="alignment">left</ac:parameter><ac:parameter ac:name="exportWidth" /><ac:parameter ac:name="height" /><ac:plain-text-body><![CDATA[[{"body":"graph TB\n    subgraph \"Client Layer\"\n        A[MCP Client] --> B[Request Queue]\n        B --> C[Load Balancer]\n    end\n    \n    subgraph \"API Gateway Layer\"\n        D[Rate Limiter] --> E[Request Throttler]\n        E --> F[Connection Pool]\n    end\n    \n    subgraph \"SpecGate Server Layer\"\n        G[Async Task Queue] --> H[Worker Pool]\n        H --> I[Memory Manager]\n        I --> J[Cache Layer]\n    end\n    \n    subgraph \"Processing Layer\"\n        K[Document Parser] --> L[Stream Processor]\n        L --> M[Batch Processor]\n        M --> N[Result Aggregator]\n    end\n    \n    subgraph \"Storage Layer\"\n        O[Redis Cache] --> P[Memory Cache]\n        P --> Q[Disk Cache]\n    end\n    \n    subgraph \"External Services\"\n        R[Confluence API] --> S[Connection Pool]\n        T[GitHub API] --> U[Connection Pool]\n    end\n    \n    A --> D\n    D --> G\n    G --> K\n    K --> O\n    G --> R\n    G --> T","date":1758265446937}]]]></ac:plain-text-body></ac:structured-macro><h3>3.2 성능 지표 및 목표</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="c04da05f-3135-4328-b251-bd842bb0d61f"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[# 성능 목표
performance_targets:
  response_time:
    confluence_fetch: "< 5초"
    speclint_lint: "< 3초"
    html_to_md: "< 2초"
    rule_extraction: "< 10초"
    spec_generation: "< 5초"
    gate_scoring: "< 3초"
  
  throughput:
    concurrent_requests: "100 req/s"
    document_processing: "50 docs/min"
    rule_extraction: "20 docs/min"
    spec_generation: "10 specs/min"
  
  resource_usage:
    memory_usage: "< 1GB"
    cpu_usage: "< 80%"
    disk_io: "< 100MB/s"
    network_io: "< 50MB/s"
  
  scalability:
    max_concurrent_users: "1000"
    max_document_size: "10MB"
    max_documents_per_request: "100"
    cache_hit_ratio: "> 80%"
]]></ac:plain-text-body></ac:structured-macro><h3>3.3 비동기 처리 최적화</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="14f5e915-ec91-48f9-9c81-4dac08c655cc"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import asyncio
import aiohttp
from typing import List, Dict, Any
from concurrent.futures import ThreadPoolExecutor
import time

class AsyncProcessor:
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
        self.semaphore = asyncio.Semaphore(max_workers)
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_documents_batch(
        self, 
        documents: List[Dict[str, Any]],
        processor_func: callable
    ) -> List[Dict[str, Any]]:
        """문서 배치 비동기 처리"""
        tasks = []
        for doc in documents:
            task = self._process_single_document(doc, processor_func)
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return [r for r in results if not isinstance(r, Exception)]
    
    async def _process_single_document(
        self, 
        document: Dict[str, Any], 
        processor_func: callable
    ) -> Dict[str, Any]:
        """단일 문서 비동기 처리"""
        async with self.semaphore:
            try:
                result = await processor_func(document)
                return result
            except Exception as e:
                return {"error": str(e), "document_id": document.get("id")}
    
    async def process_with_timeout(
        self, 
        coro, 
        timeout: float = 30.0
    ) -> Any:
        """타임아웃이 있는 비동기 처리"""
        try:
            return await asyncio.wait_for(coro, timeout=timeout)
        except asyncio.TimeoutError:
            raise TimeoutError(f"Operation timed out after {timeout} seconds")
    
    async def parallel_api_calls(
        self, 
        api_calls: List[callable]
    ) -> List[Any]:
        """병렬 API 호출"""
        tasks = [asyncio.create_task(call()) for call in api_calls]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results

class PerformanceMonitor:
    def __init__(self):
        self.metrics = {}
        self.start_times = {}
    
    def start_timer(self, operation: str) -> None:
        """타이머 시작"""
        self.start_times[operation] = time.time()
    
    def end_timer(self, operation: str) -> float:
        """타이머 종료 및 실행 시간 반환"""
        if operation not in self.start_times:
            return 0.0
        
        duration = time.time() - self.start_times[operation]
        self.metrics[operation] = duration
        del self.start_times[operation]
        return duration
    
    def get_metrics(self) -> Dict[str, float]:
        """성능 메트릭 반환"""
        return self.metrics.copy()
    
    def get_average_time(self, operation: str) -> float:
        """평균 실행 시간 반환"""
        if operation not in self.metrics:
            return 0.0
        return self.metrics[operation]
]]></ac:plain-text-body></ac:structured-macro><h3>3.4 캐싱 전략</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="8654f772-6418-4324-894b-09277f7c093b"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import redis
import json
import hashlib
from typing import Any, Optional
from datetime import datetime, timedelta

class CacheManager:
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis_client = redis.from_url(redis_url)
        self.memory_cache = {}
        self.cache_ttl = {
            'confluence_documents': 3600,  # 1시간
            'quality_scores': 1800,       # 30분
            'conversion_results': 1800,   # 30분
            'rule_extractions': 7200,     # 2시간
            'spec_generations': 7200      # 2시간
        }
    
    def _generate_cache_key(self, prefix: str, data: Dict[str, Any]) -> str:
        """캐시 키 생성"""
        data_str = json.dumps(data, sort_keys=True)
        hash_key = hashlib.md5(data_str.encode()).hexdigest()
        return f"{prefix}:{hash_key}"
    
    async def get_cached_result(
        self, 
        cache_type: str, 
        key_data: Dict[str, Any]
    ) -> Optional[Any]:
        """캐시된 결과 조회"""
        cache_key = self._generate_cache_key(cache_type, key_data)
        
        # 메모리 캐시 먼저 확인
        if cache_key in self.memory_cache:
            return self.memory_cache[cache_key]
        
        # Redis 캐시 확인
        try:
            cached_data = self.redis_client.get(cache_key)
            if cached_data:
                result = json.loads(cached_data)
                # 메모리 캐시에도 저장
                self.memory_cache[cache_key] = result
                return result
        except Exception as e:
            print(f"Redis cache error: {e}")
        
        return None
    
    async def set_cached_result(
        self, 
        cache_type: str, 
        key_data: Dict[str, Any], 
        result: Any
    ) -> None:
        """결과 캐시 저장"""
        cache_key = self._generate_cache_key(cache_type, key_data)
        ttl = self.cache_ttl.get(cache_type, 3600)
        
        # 메모리 캐시에 저장
        self.memory_cache[cache_key] = result
        
        # Redis 캐시에 저장
        try:
            serialized_data = json.dumps(result, default=str)
            self.redis_client.setex(cache_key, ttl, serialized_data)
        except Exception as e:
            print(f"Redis cache error: {e}")
    
    async def invalidate_cache(self, cache_type: str, pattern: str = None) -> None:
        """캐시 무효화"""
        if pattern:
            # 패턴 매칭으로 캐시 삭제
            keys = self.redis_client.keys(f"{cache_type}:{pattern}")
            if keys:
                self.redis_client.delete(*keys)
        else:
            # 특정 타입의 모든 캐시 삭제
            keys = self.redis_client.keys(f"{cache_type}:*")
            if keys:
                self.redis_client.delete(*keys)
        
        # 메모리 캐시도 정리
        if pattern:
            pattern_key = f"{cache_type}:{pattern}"
            self.memory_cache = {
                k: v for k, v in self.memory_cache.items() 
                if not k.startswith(pattern_key)
            }
        else:
            self.memory_cache = {
                k: v for k, v in self.memory_cache.items() 
                if not k.startswith(f"{cache_type}:")
            }
]]></ac:plain-text-body></ac:structured-macro><h3>3.5 메모리 최적화</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="b0d4e833-a1d2-4d15-9a30-a63d10eb4f66"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import gc
import psutil
import sys
from typing import Generator, Any

class MemoryManager:
    def __init__(self, max_memory_mb: int = 1024):
        self.max_memory_mb = max_memory_mb
        self.process = psutil.Process()
    
    def get_memory_usage(self) -> float:
        """현재 메모리 사용량 (MB) 반환"""
        return self.process.memory_info().rss / 1024 / 1024
    
    def check_memory_limit(self) -> bool:
        """메모리 사용량 한계 확인"""
        current_usage = self.get_memory_usage()
        return current_usage < self.max_memory_mb
    
    def force_garbage_collection(self) -> None:
        """강제 가비지 컬렉션"""
        gc.collect()
    
    def process_large_data_streaming(
        self, 
        data_generator: Generator[Any, None, None],
        processor_func: callable,
        batch_size: int = 100
    ) -> Generator[Any, None, None]:
        """대용량 데이터 스트리밍 처리"""
        batch = []
        
        for item in data_generator:
            batch.append(item)
            
            if len(batch) >= batch_size:
                # 배치 처리
                for result in processor_func(batch):
                    yield result
                
                # 메모리 정리
                batch.clear()
                self.force_garbage_collection()
                
                # 메모리 한계 확인
                if not self.check_memory_limit():
                    raise MemoryError("Memory usage exceeded limit")
        
        # 남은 배치 처리
        if batch:
            for result in processor_func(batch):
                yield result
    
    def optimize_memory_usage(self) -> Dict[str, Any]:
        """메모리 사용량 최적화"""
        before_usage = self.get_memory_usage()
        
        # 가비지 컬렉션 실행
        self.force_garbage_collection()
        
        after_usage = self.get_memory_usage()
        freed_memory = before_usage - after_usage
        
        return {
            "before_mb": before_usage,
            "after_mb": after_usage,
            "freed_mb": freed_memory,
            "current_usage_percent": (after_usage / self.max_memory_mb) * 100
        }
]]></ac:plain-text-body></ac:structured-macro><h2>4. 구현 가이드</h2><h3>4.1 성능 테스트</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="a8c5088c-989f-4844-ad62-d57f05c0dd14"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import pytest
import asyncio
import time
from unittest.mock import Mock, patch

class TestPerformance:
    @pytest.mark.asyncio
    async def test_concurrent_processing(self):
        """동시 처리 성능 테스트"""
        processor = AsyncProcessor(max_workers=5)
        
        # 테스트 데이터 생성
        documents = [{"id": i, "content": f"Document {i}"} for i in range(100)]
        
        async def mock_processor(doc):
            await asyncio.sleep(0.1)  # 처리 시뮬레이션
            return {"processed": doc["id"]}
        
        start_time = time.time()
        results = await processor.process_documents_batch(documents, mock_processor)
        end_time = time.time()
        
        # 성능 검증
        assert len(results) == 100
        assert (end_time - start_time) < 5.0  # 5초 이내 완료
        assert all("processed" in r for r in results)
    
    def test_memory_usage(self):
        """메모리 사용량 테스트"""
        memory_manager = MemoryManager(max_memory_mb=100)
        
        # 메모리 사용량 확인
        initial_usage = memory_manager.get_memory_usage()
        assert initial_usage < 100
        
        # 메모리 한계 확인
        assert memory_manager.check_memory_limit() == True
    
    def test_cache_performance(self):
        """캐시 성능 테스트"""
        cache_manager = CacheManager()
        
        # 캐시 저장
        test_data = {"key": "value", "number": 123}
        cache_manager.set_cached_result("test", {"id": 1}, test_data)
        
        # 캐시 조회
        cached_result = cache_manager.get_cached_result("test", {"id": 1})
        assert cached_result == test_data
]]></ac:plain-text-body></ac:structured-macro><h3>4.2 성능 모니터링</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="dfaf92f3-d2cf-435b-b8d8-77f9ec319610"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[import logging
from typing import Dict, Any

class PerformanceLogger:
    def __init__(self):
        self.logger = logging.getLogger("specgate.performance")
        self.logger.setLevel(logging.INFO)
    
    def log_performance_metrics(
        self, 
        operation: str, 
        duration: float, 
        memory_usage: float,
        additional_metrics: Dict[str, Any] = None
    ) -> None:
        """성능 메트릭 로깅"""
        log_data = {
            "operation": operation,
            "duration_seconds": duration,
            "memory_usage_mb": memory_usage,
            "timestamp": datetime.now().isoformat()
        }
        
        if additional_metrics:
            log_data.update(additional_metrics)
        
        self.logger.info(f"Performance metrics: {log_data}")
    
    def log_slow_operation(
        self, 
        operation: str, 
        duration: float, 
        threshold: float = 5.0
    ) -> None:
        """느린 작업 로깅"""
        if duration > threshold:
            self.logger.warning(
                f"Slow operation detected: {operation} took {duration:.2f}s "
                f"(threshold: {threshold}s)"
            )
]]></ac:plain-text-body></ac:structured-macro><h3>4.3 성능 최적화 체크리스트</h3><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="df5fdd10-9628-4803-bc1f-0f25ad0dbbd3"><ac:parameter ac:name="breakoutMode">wide</ac:parameter><ac:parameter ac:name="breakoutWidth">760</ac:parameter><ac:plain-text-body><![CDATA[# 성능 최적화 체크리스트
performance_checklist:
  async_processing:
    - [ ] 모든 I/O 작업이 비동기로 구현됨
    - [ ] 적절한 동시성 제한이 설정됨
    - [ ] 타임아웃이 모든 외부 호출에 설정됨
    - [ ] 예외 처리가 모든 비동기 작업에 포함됨
  
  memory_management:
    - [ ] 메모리 사용량이 1GB 미만으로 유지됨
    - [ ] 대용량 데이터가 스트리밍으로 처리됨
    - [ ] 가비지 컬렉션이 적절히 실행됨
    - [ ] 메모리 누수가 없음
  
  caching:
    - [ ] 반복적인 작업에 캐싱이 적용됨
    - [ ] 캐시 TTL이 적절히 설정됨
    - [ ] 캐시 무효화가 구현됨
    - [ ] 캐시 히트율이 80% 이상
  
  database_optimization:
    - [ ] 데이터베이스 쿼리가 최적화됨
    - [ ] 인덱스가 적절히 설정됨
    - [ ] 연결 풀이 구성됨
    - [ ] 쿼리 타임아웃이 설정됨
  
  monitoring:
    - [ ] 성능 메트릭이 수집됨
    - [ ] 느린 작업이 감지됨
    - [ ] 리소스 사용량이 모니터링됨
    - [ ] 알림이 설정됨
]]></ac:plain-text-body></ac:structured-macro><h2>5. 변경 이력</h2><table data-table-width="760" data-layout="default" ac:local-id="8f26552a-c835-40d3-89ae-a1f7d52b3942"><tbody><tr><th><p>버전</p></th><th><p>날짜</p></th><th><p>변경내용</p></th><th><p>작성자</p></th></tr><tr><td><p>1.0</p></td><td><p>2024-01-15</p></td><td><p>초기 성능 설계서 작성</p></td><td><p>SpecGate Team</p></td></tr></tbody></table>